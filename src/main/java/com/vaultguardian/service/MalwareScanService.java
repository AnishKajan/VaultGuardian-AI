package com.vaultguardian.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class MalwareScanService {
    
    // Known malware signatures (simplified for demo)
    private static final List<String> MALWARE_SIGNATURES = Arrays.asList(
        "EICAR-STANDARD-ANTIVIRUS-TEST-FILE",
        "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR",
        "malicious_payload",
        "trojan_dropper",
        "backdoor_shell"
    );
    
    // Suspicious file patterns
    private static final List<Pattern> SUSPICIOUS_PATTERNS = Arrays.asList(
        Pattern.compile("(?i)eval\\s*\\("),  // Code injection
        Pattern.compile("(?i)exec\\s*\\("),  // Command execution
        Pattern.compile("(?i)system\\s*\\("), // System calls
        Pattern.compile("(?i)shell_exec"), // Shell execution
        Pattern.compile("(?i)base64_decode"), // Encoded payloads
        Pattern.compile("(?i)powershell\\s+-e"), // PowerShell encoded commands
        Pattern.compile("(?i)cmd\\.exe"), // Command prompt
        Pattern.compile("(?i)\\$_GET\\["), // PHP GET injection
        Pattern.compile("(?i)\\$_POST\\["), // PHP POST injection
        Pattern.compile("(?i)<script[^>]*>"), // Script tags
        Pattern.compile("(?i)javascript:"), // JavaScript URLs
        Pattern.compile("(?i)vbscript:"), // VBScript URLs
        Pattern.compile("(?i)data:text/html") // Data URLs
    );
    
    // Individual PII patterns for counting
    private static final Pattern SSN_PATTERN = Pattern.compile("\\b\\d{3}-\\d{2}-\\d{4}\\b");
    private static final Pattern CREDIT_CARD_PATTERN = Pattern.compile("\\b(?:\\d{4}[-\\s]?){3}\\d{4}\\b");
    private static final Pattern EMAIL_PATTERN = Pattern.compile("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b");
    private static final Pattern PHONE_PATTERN = Pattern.compile("\\b\\d{3}-\\d{3}-\\d{4}\\b");
    private static final Pattern PASSPORT_PATTERN = Pattern.compile("(?i)passport\\s*#?\\s*[A-Z0-9]{6,9}");
    private static final Pattern LICENSE_PATTERN = Pattern.compile("(?i)license\\s*#?\\s*[A-Z0-9]{8,}");
    private static final Pattern ACCOUNT_PATTERN = Pattern.compile("(?i)account\\s*#?\\s*\\d{8,}");
    
    // Dangerous file extensions
    private static final List<String> DANGEROUS_EXTENSIONS = Arrays.asList(
        ".exe", ".bat", ".cmd", ".com", ".pif", ".scr", ".vbs", ".js", 
        ".jar", ".app", ".deb", ".pkg", ".dmg", ".sh", ".ps1", ".msi"
    );
    
    public MalwareScanResult scanFile(byte[] fileContent, String contentType) {
        long startTime = System.currentTimeMillis();
        log.info("Starting malware scan for file of type: {}", contentType);
        
        try {
            List<String> threats = new ArrayList<>();
            
            // Convert file content to string for pattern matching
            String fileContentStr = new String(fileContent);
            log.info("üìù File content preview (first 500 chars): {}", 
                    fileContentStr.length() > 500 ? fileContentStr.substring(0, 500) + "..." : fileContentStr);
            
            // 1. Check for known malware signatures
            threats.addAll(scanForMalwareSignatures(fileContentStr));
            
            // 2. Check for suspicious patterns
            threats.addAll(scanForSuspiciousPatterns(fileContentStr));
            
            // 3. Check for PII (Personally Identifiable Information) - ENHANCED
            threats.addAll(scanForPIIEnhanced(fileContentStr));
            
            // 4. Check file type restrictions
            threats.addAll(scanFileType(contentType));
            
            // 5. Check file size (basic validation)
            threats.addAll(scanFileSize(fileContent.length));
            
            long scanDuration = System.currentTimeMillis() - startTime;
            boolean isClean = threats.isEmpty();
            
            String details = isClean ? 
                "File passed all security scans" : 
                String.format("Found %d security issues", threats.size());
            
            log.info("üõ°Ô∏è Malware scan completed in {}ms. Clean: {}, Threats: {} - {}", 
                    scanDuration, isClean, threats.size(), threats);
            
            return MalwareScanResult.builder()
                    .isClean(isClean)
                    .details(details)
                    .threats(threats)
                    .scanEngine("VaultGuardian Security Scanner v1.0")
                    .scanDuration(scanDuration)
                    .build();
            
        } catch (Exception e) {
            log.error("Error during malware scan", e);
            return MalwareScanResult.builder()
                    .isClean(false)
                    .details("Scan failed due to technical error: " + e.getMessage())
                    .threats(Arrays.asList("Scan Error"))
                    .scanEngine("VaultGuardian Security Scanner v1.0")
                    .scanDuration(System.currentTimeMillis() - startTime)
                    .build();
        }
    }
    
    private List<String> scanForMalwareSignatures(String content) {
        List<String> threats = new ArrayList<>();
        
        for (String signature : MALWARE_SIGNATURES) {
            if (content.contains(signature)) {
                threats.add("Malware signature detected: " + signature);
                log.warn("Malware signature found: {}", signature);
            }
        }
        
        return threats;
    }
    
    private List<String> scanForSuspiciousPatterns(String content) {
        List<String> threats = new ArrayList<>();
        
        for (Pattern pattern : SUSPICIOUS_PATTERNS) {
            if (pattern.matcher(content).find()) {
                threats.add("Suspicious code pattern detected: " + pattern.pattern());
                log.warn("Suspicious pattern found: {}", pattern.pattern());
            }
        }
        
        return threats;
    }
    
    // üîß ENHANCED PII SCANNING - Counts multiple occurrences
    private List<String> scanForPIIEnhanced(String content) {
        List<String> threats = new ArrayList<>();
        
        // Count SSNs
        int ssnCount = countMatches(SSN_PATTERN, content);
        if (ssnCount > 0) {
            String threat = ssnCount == 1 ? 
                "PII detected: Social Security Number" : 
                String.format("PII detected: %d Social Security Numbers", ssnCount);
            threats.add(threat);
            log.warn("üÜî SSN found: {} occurrences", ssnCount);
        }
        
        // Count Credit Cards
        int creditCardCount = countMatches(CREDIT_CARD_PATTERN, content);
        if (creditCardCount > 0) {
            String threat = creditCardCount == 1 ? 
                "PII detected: Credit Card Number" : 
                String.format("PII detected: %d Credit Card Numbers", creditCardCount);
            threats.add(threat);
            log.warn("üí≥ Credit Card found: {} occurrences", creditCardCount);
        }
        
        // Count Emails
        int emailCount = countMatches(EMAIL_PATTERN, content);
        if (emailCount > 0) {
            String threat = emailCount == 1 ? 
                "PII detected: Email Address" : 
                String.format("PII detected: %d Email Addresses", emailCount);
            threats.add(threat);
            log.warn("üìß Email found: {} occurrences", emailCount);
        }
        
        // Count Phone Numbers
        int phoneCount = countMatches(PHONE_PATTERN, content);
        if (phoneCount > 0) {
            String threat = phoneCount == 1 ? 
                "PII detected: Phone Number" : 
                String.format("PII detected: %d Phone Numbers", phoneCount);
            threats.add(threat);
            log.warn("üìû Phone found: {} occurrences", phoneCount);
        }
        
        // Check for other patterns (single occurrence)
        if (PASSPORT_PATTERN.matcher(content).find()) {
            threats.add("PII detected: Passport Number");
            log.warn("üõÇ Passport Number found");
        }
        
        if (LICENSE_PATTERN.matcher(content).find()) {
            threats.add("PII detected: Driver's License");
            log.warn("ü™™ Driver's License found");
        }
        
        if (ACCOUNT_PATTERN.matcher(content).find()) {
            threats.add("PII detected: Account Number");
            log.warn("üè¶ Account Number found");
        }
        
        // Check for confidential keywords
        if (content.toLowerCase().contains("confidential")) {
            threats.add("PII detected: Confidential Content");
            log.warn("üîí Confidential content found");
        }
        
        if (content.toLowerCase().contains("restricted")) {
            threats.add("PII detected: Restricted Content");
            log.warn("üö´ Restricted content found");
        }
        
        if (content.toLowerCase().contains("classified")) {
            threats.add("PII detected: Classified Content");
            log.warn("üîê Classified content found");
        }
        
        return threats;
    }
    
    // Helper method to count pattern matches
    private int countMatches(Pattern pattern, String content) {
        Matcher matcher = pattern.matcher(content);
        int count = 0;
        while (matcher.find()) {
            count++;
            log.debug("Found match: {}", matcher.group());
        }
        return count;
    }
    
    private List<String> scanFileType(String contentType) {
        List<String> threats = new ArrayList<>();
        
        if (contentType == null) {
            threats.add("Unknown file type - security risk");
            return threats;
        }
        
        // Check for dangerous MIME types
        if (contentType.startsWith("application/x-executable") ||
            contentType.startsWith("application/x-msdownload") ||
            contentType.startsWith("application/x-msdos-program")) {
            threats.add("Executable file type detected - potential security risk");
        }
        
        // Check for script types
        if (contentType.contains("javascript") || 
            contentType.contains("vbscript") ||
            contentType.contains("x-sh")) {
            threats.add("Script file detected - potential security risk");
        }
        
        return threats;
    }
    
    private List<String> scanFileSize(long fileSize) {
        List<String> threats = new ArrayList<>();
        
        // Check for suspiciously large files (over 100MB)
        if (fileSize > 100 * 1024 * 1024) {
            threats.add("File size exceeds security limits");
        }
        
        // Check for suspiciously small files that claim to be documents
        if (fileSize < 100) {
            threats.add("Suspiciously small file size");
        }
        
        return threats;
    }
    
    public boolean isFileTypeAllowed(String filename, String contentType) {
        if (filename == null || contentType == null) {
            return false;
        }
        
        // Check file extension
        String lowerFilename = filename.toLowerCase();
        for (String ext : DANGEROUS_EXTENSIONS) {
            if (lowerFilename.endsWith(ext)) {
                log.warn("Dangerous file extension detected: {}", ext);
                return false;
            }
        }
        
        // Allow common document types
        return contentType.startsWith("text/") ||
               contentType.startsWith("image/") ||
               contentType.equals("application/pdf") ||
               contentType.equals("application/msword") ||
               contentType.equals("application/vnd.openxmlformats-officedocument") ||
               contentType.equals("application/vnd.ms-excel") ||
               contentType.equals("application/vnd.ms-powerpoint") ||
               contentType.equals("application/json") ||
               contentType.equals("application/xml");
    }
}